import {
  Fragment,
  computed,
  createElementBlock,
  createRenderer,
  customRef,
  defineComponent,
  getCurrentInstance,
  getCurrentScope,
  h,
  inject,
  isRef,
  nextTick,
  normalizeClass,
  normalizeStyle,
  onMounted,
  onScopeDispose,
  onUnmounted,
  openBlock,
  provide,
  reactive,
  readonly,
  ref,
  shallowRef,
  toRefs,
  unref,
  useSlots,
  watch,
  watchEffect
} from "./chunk-ZY5X6FX7.js";
import {
  ACESFilmicToneMapping,
  ArrowHelper,
  BackSide,
  BufferAttribute,
  BufferGeometry,
  Camera,
  Clock,
  Color,
  DirectionalLightHelper,
  DoubleSide,
  Float32BufferAttribute,
  HemisphereLightHelper,
  Line,
  LineBasicMaterial,
  Mesh,
  MeshBasicMaterial,
  OrthographicCamera,
  PCFSoftShadowMap,
  PerspectiveCamera,
  PointLightHelper,
  Quaternion,
  REVISION,
  Raycaster,
  SRGBColorSpace,
  Scene,
  SpotLightHelper,
  TextureLoader,
  Vector2,
  Vector3,
  WebGLRenderer,
  three_module_exports
} from "./chunk-IV45K6BK.js";

// node_modules/@vueuse/shared/index.mjs
function tryOnScopeDispose(fn) {
  if (getCurrentScope()) {
    onScopeDispose(fn);
    return true;
  }
  return false;
}
function createEventHook() {
  const fns = /* @__PURE__ */ new Set();
  const off = (fn) => {
    fns.delete(fn);
  };
  const on = (fn) => {
    fns.add(fn);
    const offFn = () => off(fn);
    tryOnScopeDispose(offFn);
    return {
      off: offFn
    };
  };
  const trigger = (...args) => {
    return Promise.all(Array.from(fns).map((fn) => fn(...args)));
  };
  return {
    on,
    off,
    trigger
  };
}
function toValue(r) {
  return typeof r === "function" ? r() : unref(r);
}
var isClient = typeof window !== "undefined" && typeof document !== "undefined";
var isWorker = typeof WorkerGlobalScope !== "undefined" && globalThis instanceof WorkerGlobalScope;
var notNullish = (val) => val != null;
var toString = Object.prototype.toString;
var isObject = (val) => toString.call(val) === "[object Object]";
var noop = () => {
};
var isIOS = getIsIOS();
function getIsIOS() {
  var _a, _b;
  return isClient && ((_a = window == null ? void 0 : window.navigator) == null ? void 0 : _a.userAgent) && (/iP(?:ad|hone|od)/.test(window.navigator.userAgent) || ((_b = window == null ? void 0 : window.navigator) == null ? void 0 : _b.maxTouchPoints) > 2 && /iPad|Macintosh/.test(window == null ? void 0 : window.navigator.userAgent));
}
function createFilterWrapper(filter, fn) {
  function wrapper(...args) {
    return new Promise((resolve, reject) => {
      Promise.resolve(filter(() => fn.apply(this, args), { fn, thisArg: this, args })).then(resolve).catch(reject);
    });
  }
  return wrapper;
}
function debounceFilter(ms, options = {}) {
  let timer;
  let maxTimer;
  let lastRejector = noop;
  const _clearTimeout = (timer2) => {
    clearTimeout(timer2);
    lastRejector();
    lastRejector = noop;
  };
  const filter = (invoke) => {
    const duration = toValue(ms);
    const maxDuration = toValue(options.maxWait);
    if (timer)
      _clearTimeout(timer);
    if (duration <= 0 || maxDuration !== void 0 && maxDuration <= 0) {
      if (maxTimer) {
        _clearTimeout(maxTimer);
        maxTimer = null;
      }
      return Promise.resolve(invoke());
    }
    return new Promise((resolve, reject) => {
      lastRejector = options.rejectOnCancel ? reject : resolve;
      if (maxDuration && !maxTimer) {
        maxTimer = setTimeout(() => {
          if (timer)
            _clearTimeout(timer);
          maxTimer = null;
          resolve(invoke());
        }, maxDuration);
      }
      timer = setTimeout(() => {
        if (maxTimer)
          _clearTimeout(maxTimer);
        maxTimer = null;
        resolve(invoke());
      }, duration);
    });
  };
  return filter;
}
function cacheStringFunction(fn) {
  const cache = /* @__PURE__ */ Object.create(null);
  return (str) => {
    const hit = cache[str];
    return hit || (cache[str] = fn(str));
  };
}
var hyphenateRE = /\B([A-Z])/g;
var hyphenate = cacheStringFunction((str) => str.replace(hyphenateRE, "-$1").toLowerCase());
var camelizeRE = /-(\w)/g;
var camelize = cacheStringFunction((str) => {
  return str.replace(camelizeRE, (_, c) => c ? c.toUpperCase() : "");
});
function identity(arg) {
  return arg;
}
function objectPick(obj, keys2, omitUndefined = false) {
  return keys2.reduce((n, k2) => {
    if (k2 in obj) {
      if (!omitUndefined || obj[k2] !== void 0)
        n[k2] = obj[k2];
    }
    return n;
  }, {});
}
function getLifeCycleTarget(target) {
  return target || getCurrentInstance();
}
function useDebounceFn(fn, ms = 200, options = {}) {
  return createFilterWrapper(
    debounceFilter(ms, options),
    fn
  );
}
function refDebounced(value, ms = 200, options = {}) {
  const debounced = ref(value.value);
  const updater = useDebounceFn(() => {
    debounced.value = value.value;
  }, ms, options);
  watch(value, () => updater());
  return debounced;
}
function toRefs2(objectRef, options = {}) {
  if (!isRef(objectRef))
    return toRefs(objectRef);
  const result = Array.isArray(objectRef.value) ? Array.from({ length: objectRef.value.length }) : {};
  for (const key in objectRef.value) {
    result[key] = customRef(() => ({
      get() {
        return objectRef.value[key];
      },
      set(v) {
        var _a;
        const replaceRef = (_a = toValue(options.replaceRef)) != null ? _a : true;
        if (replaceRef) {
          if (Array.isArray(objectRef.value)) {
            const copy = [...objectRef.value];
            copy[key] = v;
            objectRef.value = copy;
          } else {
            const newObject = { ...objectRef.value, [key]: v };
            Object.setPrototypeOf(newObject, Object.getPrototypeOf(objectRef.value));
            objectRef.value = newObject;
          }
        } else {
          objectRef.value[key] = v;
        }
      }
    }));
  }
  return result;
}
function tryOnMounted(fn, sync = true, target) {
  const instance = getLifeCycleTarget();
  if (instance)
    onMounted(fn, target);
  else if (sync)
    fn();
  else
    nextTick(fn);
}
function useIntervalFn(cb, interval = 1e3, options = {}) {
  const {
    immediate = true,
    immediateCallback = false
  } = options;
  let timer = null;
  const isActive = ref(false);
  function clean() {
    if (timer) {
      clearInterval(timer);
      timer = null;
    }
  }
  function pause() {
    isActive.value = false;
    clean();
  }
  function resume() {
    const intervalValue = toValue(interval);
    if (intervalValue <= 0)
      return;
    isActive.value = true;
    if (immediateCallback)
      cb();
    clean();
    timer = setInterval(cb, intervalValue);
  }
  if (immediate && isClient)
    resume();
  if (isRef(interval) || typeof interval === "function") {
    const stopWatch = watch(interval, () => {
      if (isActive.value && isClient)
        resume();
    });
    tryOnScopeDispose(stopWatch);
  }
  tryOnScopeDispose(pause);
  return {
    isActive,
    pause,
    resume
  };
}

// node_modules/@vueuse/core/node_modules/vue-demi/lib/index.mjs
var isVue22 = false;

// node_modules/@vueuse/core/index.mjs
function unrefElement(elRef) {
  var _a;
  const plain = toValue(elRef);
  return (_a = plain == null ? void 0 : plain.$el) != null ? _a : plain;
}
var defaultWindow = isClient ? window : void 0;
var defaultDocument = isClient ? window.document : void 0;
var defaultNavigator = isClient ? window.navigator : void 0;
var defaultLocation = isClient ? window.location : void 0;
function useEventListener(...args) {
  let target;
  let events;
  let listeners;
  let options;
  if (typeof args[0] === "string" || Array.isArray(args[0])) {
    [events, listeners, options] = args;
    target = defaultWindow;
  } else {
    [target, events, listeners, options] = args;
  }
  if (!target)
    return noop;
  if (!Array.isArray(events))
    events = [events];
  if (!Array.isArray(listeners))
    listeners = [listeners];
  const cleanups = [];
  const cleanup = () => {
    cleanups.forEach((fn) => fn());
    cleanups.length = 0;
  };
  const register = (el, event, listener, options2) => {
    el.addEventListener(event, listener, options2);
    return () => el.removeEventListener(event, listener, options2);
  };
  const stopWatch = watch(
    () => [unrefElement(target), toValue(options)],
    ([el, options2]) => {
      cleanup();
      if (!el)
        return;
      const optionsClone = isObject(options2) ? { ...options2 } : options2;
      cleanups.push(
        ...events.flatMap((event) => {
          return listeners.map((listener) => register(el, event, listener, optionsClone));
        })
      );
    },
    { immediate: true, flush: "post" }
  );
  const stop = () => {
    stopWatch();
    cleanup();
  };
  tryOnScopeDispose(stop);
  return stop;
}
function useMounted() {
  const isMounted = ref(false);
  const instance = getCurrentInstance();
  if (instance) {
    onMounted(() => {
      isMounted.value = true;
    }, isVue22 ? void 0 : instance);
  }
  return isMounted;
}
function useSupported(callback) {
  const isMounted = useMounted();
  return computed(() => {
    isMounted.value;
    return Boolean(callback());
  });
}
function useMutationObserver(target, callback, options = {}) {
  const { window: window2 = defaultWindow, ...mutationOptions } = options;
  let observer;
  const isSupported = useSupported(() => window2 && "MutationObserver" in window2);
  const cleanup = () => {
    if (observer) {
      observer.disconnect();
      observer = void 0;
    }
  };
  const targets = computed(() => {
    const value = toValue(target);
    const items = (Array.isArray(value) ? value : [value]).map(unrefElement).filter(notNullish);
    return new Set(items);
  });
  const stopWatch = watch(
    () => targets.value,
    (targets2) => {
      cleanup();
      if (isSupported.value && targets2.size) {
        observer = new MutationObserver(callback);
        targets2.forEach((el) => observer.observe(el, mutationOptions));
      }
    },
    { immediate: true, flush: "post" }
  );
  const takeRecords = () => {
    return observer == null ? void 0 : observer.takeRecords();
  };
  const stop = () => {
    cleanup();
    stopWatch();
  };
  tryOnScopeDispose(stop);
  return {
    isSupported,
    stop,
    takeRecords
  };
}
function useRafFn(fn, options = {}) {
  const {
    immediate = true,
    fpsLimit = void 0,
    window: window2 = defaultWindow
  } = options;
  const isActive = ref(false);
  const intervalLimit = fpsLimit ? 1e3 / fpsLimit : null;
  let previousFrameTimestamp = 0;
  let rafId = null;
  function loop(timestamp2) {
    if (!isActive.value || !window2)
      return;
    if (!previousFrameTimestamp)
      previousFrameTimestamp = timestamp2;
    const delta = timestamp2 - previousFrameTimestamp;
    if (intervalLimit && delta < intervalLimit) {
      rafId = window2.requestAnimationFrame(loop);
      return;
    }
    previousFrameTimestamp = timestamp2;
    fn({ delta, timestamp: timestamp2 });
    rafId = window2.requestAnimationFrame(loop);
  }
  function resume() {
    if (!isActive.value && window2) {
      isActive.value = true;
      previousFrameTimestamp = 0;
      rafId = window2.requestAnimationFrame(loop);
    }
  }
  function pause() {
    isActive.value = false;
    if (rafId != null && window2) {
      window2.cancelAnimationFrame(rafId);
      rafId = null;
    }
  }
  if (immediate)
    resume();
  tryOnScopeDispose(pause);
  return {
    isActive: readonly(isActive),
    pause,
    resume
  };
}
function useMediaQuery(query, options = {}) {
  const { window: window2 = defaultWindow } = options;
  const isSupported = useSupported(() => window2 && "matchMedia" in window2 && typeof window2.matchMedia === "function");
  let mediaQuery;
  const matches = ref(false);
  const handler = (event) => {
    matches.value = event.matches;
  };
  const cleanup = () => {
    if (!mediaQuery)
      return;
    if ("removeEventListener" in mediaQuery)
      mediaQuery.removeEventListener("change", handler);
    else
      mediaQuery.removeListener(handler);
  };
  const stopWatch = watchEffect(() => {
    if (!isSupported.value)
      return;
    cleanup();
    mediaQuery = window2.matchMedia(toValue(query));
    if ("addEventListener" in mediaQuery)
      mediaQuery.addEventListener("change", handler);
    else
      mediaQuery.addListener(handler);
    matches.value = mediaQuery.matches;
  });
  tryOnScopeDispose(() => {
    stopWatch();
    cleanup();
    mediaQuery = void 0;
  });
  return matches;
}
var _global = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
var globalKey = "__vueuse_ssr_handlers__";
var handlers = getHandlers();
function getHandlers() {
  if (!(globalKey in _global))
    _global[globalKey] = _global[globalKey] || {};
  return _global[globalKey];
}
function useDevicePixelRatio(options = {}) {
  const {
    window: window2 = defaultWindow
  } = options;
  const pixelRatio = ref(1);
  if (window2) {
    let observe2 = function() {
      pixelRatio.value = window2.devicePixelRatio;
      cleanup2();
      media = window2.matchMedia(`(resolution: ${pixelRatio.value}dppx)`);
      media.addEventListener("change", observe2, { once: true });
    }, cleanup2 = function() {
      media == null ? void 0 : media.removeEventListener("change", observe2);
    };
    let media;
    observe2();
    tryOnScopeDispose(cleanup2);
  }
  return { pixelRatio };
}
function useResizeObserver(target, callback, options = {}) {
  const { window: window2 = defaultWindow, ...observerOptions } = options;
  let observer;
  const isSupported = useSupported(() => window2 && "ResizeObserver" in window2);
  const cleanup = () => {
    if (observer) {
      observer.disconnect();
      observer = void 0;
    }
  };
  const targets = computed(() => Array.isArray(target) ? target.map((el) => unrefElement(el)) : [unrefElement(target)]);
  const stopWatch = watch(
    targets,
    (els) => {
      cleanup();
      if (isSupported.value && window2) {
        observer = new ResizeObserver(callback);
        for (const _el of els)
          _el && observer.observe(_el, observerOptions);
      }
    },
    { immediate: true, flush: "post" }
  );
  const stop = () => {
    cleanup();
    stopWatch();
  };
  tryOnScopeDispose(stop);
  return {
    isSupported,
    stop
  };
}
function useElementBounding(target, options = {}) {
  const {
    reset = true,
    windowResize = true,
    windowScroll = true,
    immediate = true
  } = options;
  const height = ref(0);
  const bottom = ref(0);
  const left = ref(0);
  const right = ref(0);
  const top = ref(0);
  const width = ref(0);
  const x = ref(0);
  const y = ref(0);
  function update() {
    const el = unrefElement(target);
    if (!el) {
      if (reset) {
        height.value = 0;
        bottom.value = 0;
        left.value = 0;
        right.value = 0;
        top.value = 0;
        width.value = 0;
        x.value = 0;
        y.value = 0;
      }
      return;
    }
    const rect = el.getBoundingClientRect();
    height.value = rect.height;
    bottom.value = rect.bottom;
    left.value = rect.left;
    right.value = rect.right;
    top.value = rect.top;
    width.value = rect.width;
    x.value = rect.x;
    y.value = rect.y;
  }
  useResizeObserver(target, update);
  watch(() => unrefElement(target), (ele) => !ele && update());
  useMutationObserver(target, update, {
    attributeFilter: ["style", "class"]
  });
  if (windowScroll)
    useEventListener("scroll", update, { capture: true, passive: true });
  if (windowResize)
    useEventListener("resize", update, { passive: true });
  tryOnMounted(() => {
    if (immediate)
      update();
  });
  return {
    height,
    bottom,
    left,
    right,
    top,
    width,
    x,
    y,
    update
  };
}
function useElementSize(target, initialSize = { width: 0, height: 0 }, options = {}) {
  const { window: window2 = defaultWindow, box = "content-box" } = options;
  const isSVG = computed(() => {
    var _a, _b;
    return (_b = (_a = unrefElement(target)) == null ? void 0 : _a.namespaceURI) == null ? void 0 : _b.includes("svg");
  });
  const width = ref(initialSize.width);
  const height = ref(initialSize.height);
  const { stop: stop1 } = useResizeObserver(
    target,
    ([entry]) => {
      const boxSize = box === "border-box" ? entry.borderBoxSize : box === "content-box" ? entry.contentBoxSize : entry.devicePixelContentBoxSize;
      if (window2 && isSVG.value) {
        const $elem = unrefElement(target);
        if ($elem) {
          const rect = $elem.getBoundingClientRect();
          width.value = rect.width;
          height.value = rect.height;
        }
      } else {
        if (boxSize) {
          const formatBoxSize = Array.isArray(boxSize) ? boxSize : [boxSize];
          width.value = formatBoxSize.reduce((acc, { inlineSize }) => acc + inlineSize, 0);
          height.value = formatBoxSize.reduce((acc, { blockSize }) => acc + blockSize, 0);
        } else {
          width.value = entry.contentRect.width;
          height.value = entry.contentRect.height;
        }
      }
    },
    options
  );
  tryOnMounted(() => {
    const ele = unrefElement(target);
    if (ele) {
      width.value = "offsetWidth" in ele ? ele.offsetWidth : initialSize.width;
      height.value = "offsetHeight" in ele ? ele.offsetHeight : initialSize.height;
    }
  });
  const stop2 = watch(
    () => unrefElement(target),
    (ele) => {
      width.value = ele ? initialSize.width : 0;
      height.value = ele ? initialSize.height : 0;
    }
  );
  function stop() {
    stop1();
    stop2();
  }
  return {
    width,
    height,
    stop
  };
}
function useFps(options) {
  var _a;
  const fps = ref(0);
  if (typeof performance === "undefined")
    return fps;
  const every = (_a = options == null ? void 0 : options.every) != null ? _a : 10;
  let last = performance.now();
  let ticks = 0;
  useRafFn(() => {
    ticks += 1;
    if (ticks >= every) {
      const now = performance.now();
      const diff = now - last;
      fps.value = Math.round(1e3 / (diff / ticks));
      last = now;
      ticks = 0;
    }
  });
  return fps;
}
function useMemory(options = {}) {
  const memory = ref();
  const isSupported = useSupported(() => typeof performance !== "undefined" && "memory" in performance);
  if (isSupported.value) {
    const { interval = 1e3 } = options;
    useIntervalFn(() => {
      memory.value = performance.memory;
    }, interval, { immediate: options.immediate, immediateCallback: options.immediateCallback });
  }
  return { isSupported, memory };
}
var defaultState = {
  x: 0,
  y: 0,
  pointerId: 0,
  pressure: 0,
  tiltX: 0,
  tiltY: 0,
  width: 0,
  height: 0,
  twist: 0,
  pointerType: null
};
var keys = Object.keys(defaultState);
function usePointer(options = {}) {
  const {
    target = defaultWindow
  } = options;
  const isInside = ref(false);
  const state = ref(options.initialValue || {});
  Object.assign(state.value, defaultState, state.value);
  const handler = (event) => {
    isInside.value = true;
    if (options.pointerTypes && !options.pointerTypes.includes(event.pointerType))
      return;
    state.value = objectPick(event, keys, false);
  };
  if (target) {
    const listenerOptions = { passive: true };
    useEventListener(target, ["pointerdown", "pointermove", "pointerup"], handler, listenerOptions);
    useEventListener(target, "pointerleave", () => isInside.value = false, listenerOptions);
  }
  return {
    ...toRefs2(state),
    isInside
  };
}
var DEFAULT_UNITS = [
  { max: 6e4, value: 1e3, name: "second" },
  { max: 276e4, value: 6e4, name: "minute" },
  { max: 72e6, value: 36e5, name: "hour" },
  { max: 5184e5, value: 864e5, name: "day" },
  { max: 24192e5, value: 6048e5, name: "week" },
  { max: 28512e6, value: 2592e6, name: "month" },
  { max: Number.POSITIVE_INFINITY, value: 31536e6, name: "year" }
];
var _TransitionPresets = {
  easeInSine: [0.12, 0, 0.39, 0],
  easeOutSine: [0.61, 1, 0.88, 1],
  easeInOutSine: [0.37, 0, 0.63, 1],
  easeInQuad: [0.11, 0, 0.5, 0],
  easeOutQuad: [0.5, 1, 0.89, 1],
  easeInOutQuad: [0.45, 0, 0.55, 1],
  easeInCubic: [0.32, 0, 0.67, 0],
  easeOutCubic: [0.33, 1, 0.68, 1],
  easeInOutCubic: [0.65, 0, 0.35, 1],
  easeInQuart: [0.5, 0, 0.75, 0],
  easeOutQuart: [0.25, 1, 0.5, 1],
  easeInOutQuart: [0.76, 0, 0.24, 1],
  easeInQuint: [0.64, 0, 0.78, 0],
  easeOutQuint: [0.22, 1, 0.36, 1],
  easeInOutQuint: [0.83, 0, 0.17, 1],
  easeInExpo: [0.7, 0, 0.84, 0],
  easeOutExpo: [0.16, 1, 0.3, 1],
  easeInOutExpo: [0.87, 0, 0.13, 1],
  easeInCirc: [0.55, 0, 1, 0.45],
  easeOutCirc: [0, 0.55, 0.45, 1],
  easeInOutCirc: [0.85, 0, 0.15, 1],
  easeInBack: [0.36, 0, 0.66, -0.56],
  easeOutBack: [0.34, 1.56, 0.64, 1],
  easeInOutBack: [0.68, -0.6, 0.32, 1.6]
};
var TransitionPresets = Object.assign({}, { linear: identity }, _TransitionPresets);
function useWindowSize(options = {}) {
  const {
    window: window2 = defaultWindow,
    initialWidth = Number.POSITIVE_INFINITY,
    initialHeight = Number.POSITIVE_INFINITY,
    listenOrientation = true,
    includeScrollbar = true
  } = options;
  const width = ref(initialWidth);
  const height = ref(initialHeight);
  const update = () => {
    if (window2) {
      if (includeScrollbar) {
        width.value = window2.innerWidth;
        height.value = window2.innerHeight;
      } else {
        width.value = window2.document.documentElement.clientWidth;
        height.value = window2.document.documentElement.clientHeight;
      }
    }
  };
  update();
  tryOnMounted(update);
  useEventListener("resize", update, { passive: true });
  if (listenOrientation) {
    const matches = useMediaQuery("(orientation: portrait)");
    watch(matches, () => update());
  }
  return { width, height };
}

// node_modules/@tresjs/core/dist/tres.js
var Oe = Object.defineProperty;
var De = (e, r, t) => r in e ? Oe(e, r, { enumerable: true, configurable: true, writable: true, value: t }) : e[r] = t;
var Q = (e, r, t) => (De(e, typeof r != "symbol" ? r + "" : r, t), t);
var bt = "@tresjs/core";
var Et = "module";
var Ct = "3.9.0";
var xt = "pnpm@8.15.6";
var Mt = "Declarative ThreeJS using Vue Components";
var St = "Alvaro Saburido <hola@alvarosaburido.dev> (https://github.com/alvarosabu/)";
var kt = "MIT";
var Pt = [
  "vue",
  "3d",
  "threejs",
  "three",
  "threejs-vue"
];
var Tt = false;
var At = {
  ".": {
    types: "./dist/index.d.ts",
    import: "./dist/tres.js",
    require: "./dist/tres.umd.cjs"
  },
  "./components": {
    types: "./dist/src/components/index.d.ts"
  },
  "./composables": {
    types: "./dist/src/composables/index.d.ts"
  },
  "./types": {
    types: "./dist/src/types/index.d.ts"
  },
  "./utils": {
    types: "./dist/src/utils/index.d.ts"
  },
  "./*": "./*"
};
var Lt = "./dist/tres.js";
var Ot = "./dist/tres.js";
var Dt = "./dist/index.d.ts";
var Bt = [
  "*.d.ts",
  "dist"
];
var jt = {
  access: "public"
};
var Ht = {
  dev: "cd playground && npm run dev",
  build: "vite build",
  playground: "cd playground && npm run dev",
  test: "vitest",
  "test:ci": "vitest run",
  "test:ui": "vitest --ui",
  release: "release-it",
  coverage: "vitest run --coverage",
  lint: "eslint .",
  "lint:fix": "eslint . --fix",
  "docs:dev": "vitepress dev docs",
  "docs:build": "vitepress build docs",
  "docs:serve": "vitepress serve docs",
  "docs:preview": "vitepress preview docs",
  "docs:contributors": "esno scripts/update-contributors.ts",
  prepare: "node .husky/install.mjs"
};
var Rt = {
  three: ">=0.133",
  vue: ">=3.3"
};
var It = {
  "@alvarosabu/utils": "^3.1.1",
  "@vue/devtools-api": "^6.6.1",
  "@vueuse/core": "^10.7.0"
};
var $t = {
  "@release-it/conventional-changelog": "^8.0.1",
  "@stackblitz/sdk": "^1.9.0",
  "@tresjs/cientos": "3.8.0",
  "@tresjs/eslint-config": "^1.0.0",
  "@tresjs/eslint-config-vue": "^0.2.1",
  "@types/three": "^0.163.0",
  "@typescript-eslint/eslint-plugin": "^7.7.1",
  "@typescript-eslint/parser": "^7.7.1",
  "@vitejs/plugin-vue": "^5.0.4",
  "@vitest/coverage-c8": "^0.33.0",
  "@vitest/ui": "^1.5.0",
  "@vue/test-utils": "^2.4.3",
  eslint: "^9.1.1",
  "eslint-plugin-vue": "^9.25.0",
  esno: "^4.0.0",
  gsap: "^3.12.3",
  husky: "^9.0.11",
  jsdom: "^24.0.0",
  kolorist: "^1.8.0",
  ohmyfetch: "^0.4.21",
  pathe: "^1.1.1",
  "release-it": "^17.2.0",
  "rollup-plugin-analyzer": "^4.0.0",
  "rollup-plugin-copy": "^3.5.0",
  "rollup-plugin-visualizer": "^5.11.0",
  three: "^0.163.0",
  unocss: "^0.59.4",
  unplugin: "^1.10.1",
  "unplugin-vue-components": "^0.26.0",
  vite: "^5.2.10",
  "vite-plugin-banner": "^0.7.1",
  "vite-plugin-dts": "3.9.0",
  "vite-plugin-inspect": "^0.8.4",
  "vite-plugin-require-transform": "^1.0.21",
  "vite-svg-loader": "^5.1.0",
  vitepress: "1.1.3",
  vitest: "^1.5.0",
  vue: "^3.4.24",
  "vue-demi": "^0.14.6"
};
var zt = {
  name: bt,
  type: Et,
  version: Ct,
  packageManager: xt,
  description: Mt,
  author: St,
  license: kt,
  keywords: Pt,
  sideEffects: Tt,
  exports: At,
  main: Lt,
  module: Ot,
  types: Dt,
  files: Bt,
  publishConfig: jt,
  scripts: Ht,
  peerDependencies: Rt,
  dependencies: It,
  devDependencies: $t
};
var Nt = ({ sizes: e, scene: r }) => {
  const t = ref([]), o = computed(
    () => t.value[0]
  ), s = (a) => {
    const l = a instanceof Camera ? a : t.value.find((m) => m.uuid === a);
    if (!l)
      return;
    const c = t.value.filter(({ uuid: m }) => m !== l.uuid);
    t.value = [l, ...c];
  }, i = (a, l = false) => {
    t.value.some(({ uuid: c }) => c === a.uuid) || (l ? s(a) : t.value.push(a));
  }, n = (a) => {
    t.value = t.value.filter(({ uuid: l }) => l !== a.uuid);
  };
  return watchEffect(() => {
    e.aspectRatio.value && t.value.forEach((a) => {
      a instanceof PerspectiveCamera && (a.aspect = e.aspectRatio.value), (a instanceof PerspectiveCamera || a instanceof OrthographicCamera) && a.updateProjectionMatrix();
    });
  }), r.userData.tres__registerCamera = i, r.userData.tres__deregisterCamera = n, onUnmounted(() => {
    t.value = [];
  }), {
    camera: o,
    cameras: t,
    registerCamera: i,
    deregisterCamera: n,
    setCameraActive: s
  };
};
var _e = createEventHook();
var be = createEventHook();
var re = createEventHook();
var j = new Clock();
var V = 0;
var F = 0;
var { pause: Wt, resume: Vt, isActive: Ft } = useRafFn(
  () => {
    _e.trigger({ delta: V, elapsed: F, clock: j }), be.trigger({ delta: V, elapsed: F, clock: j }), re.trigger({ delta: V, elapsed: F, clock: j });
  },
  { immediate: false }
);
re.on(() => {
  V = j.getDelta(), F = j.getElapsedTime();
});
var G = () => ({
  onBeforeLoop: _e.on,
  onLoop: be.on,
  onAfterLoop: re.on,
  pause: Wt,
  resume: Vt,
  isActive: Ft
});
var Ir = true;
var I = "[TresJS ▲ ■ ●] ";
function P() {
  function e(...o) {
    typeof o[0] == "string" ? o[0] = I + o[0] : o.unshift(I), console.error(...o);
  }
  function r(...o) {
    typeof o[0] == "string" ? o[0] = I + o[0] : o.unshift(I), console.warn(...o);
  }
  function t(o, s) {
  }
  return {
    logError: e,
    logWarning: r,
    logMessage: t
  };
}
function $r(e) {
  return typeof e == "number" ? [e, e, e] : e instanceof Vector3 ? [e.x, e.y, e.z] : e;
}
function Ut(e) {
  return e instanceof Color ? e : Array.isArray(e) ? new Color(...e) : new Color(e);
}
var Gt = class extends Mesh {
  constructor(...t) {
    super(...t);
    Q(this, "type", "HightlightMesh");
    Q(this, "createTime");
    this.createTime = Date.now();
  }
  onBeforeRender() {
    const o = (Date.now() - this.createTime) / 1e3, n = 1 + 0.07 * Math.sin(2.5 * o);
    this.scale.set(n, n, n);
  }
};
var Ee = (e, r) => {
  for (const t of Object.keys(r))
    r[t] instanceof Object && Object.assign(r[t], Ee(e[t], r[t]));
  return Object.assign(e || {}, r), e;
};
var Qt = "html,body,base,head,link,meta,style,title,address,article,aside,footer,header,hgroup,h1,h2,h3,h4,h5,h6,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,summary,template,blockquote,iframe,tfoot";
var qt = Jt(Qt);
function ce(e) {
  return e && e.nodeType === 1;
}
function $(e) {
  return e.replace(/-([a-z])/g, (r, t) => t.toUpperCase());
}
function Jt(e, r) {
  const t = /* @__PURE__ */ Object.create(null), o = e.split(",");
  for (let s = 0; s < o.length; s++)
    t[o[s]] = true;
  return r ? (s) => !!t[s.toLowerCase()] : (s) => !!t[s];
}
var Yt = (e, r) => {
  const t = /* @__PURE__ */ new Set(), o = [];
  for (const s of e) {
    const i = r(s);
    t.has(i) || (t.add(i), o.push(s));
  }
  return o;
};
var de = (e, r) => {
  if (!r)
    return;
  const t = Array.isArray(r) ? r : r.match(/([^[.\]])+/g);
  return t == null ? void 0 : t.reduce((o, s) => o && o[s], e);
};
var Kt = (e, r, t) => {
  const o = Array.isArray(r) ? r : r.match(/([^[.\]])+/g);
  o && o.reduce((s, i, n) => (s[i] === void 0 && (s[i] = {}), n === o.length - 1 && (s[i] = t), s[i]), e);
};
function Ce(e, r) {
  if (ce(e) && ce(r)) {
    const s = e.attributes, i = r.attributes;
    return s.length !== i.length ? false : Array.from(s).every(({ name: n, value: a }) => r.getAttribute(n) === a);
  }
  if (e === r)
    return true;
  if (e === null || typeof e != "object" || r === null || typeof r != "object")
    return false;
  const t = Object.keys(e), o = Object.keys(r);
  if (t.length !== o.length)
    return false;
  for (const s of t)
    if (!o.includes(s) || !Ce(e[s], r[s]))
      return false;
  return true;
}
function Xt(e, r) {
  if (!Array.isArray(e) || !Array.isArray(r) || e.length !== r.length)
    return false;
  for (let t = 0; t < e.length; t++)
    if (!Ce(e[t], r[t]))
      return false;
  return true;
}
var Zt = Array.isArray;
function er(e, r, t, o) {
  const s = (l) => {
    if (l.uuid === r)
      return l;
    for (const c of l.children) {
      const m = s(c);
      if (m)
        return m;
    }
  }, i = s(e);
  if (!i) {
    console.warn("Object with UUID not found in the scene.");
    return;
  }
  let n = i;
  for (let l = 0; l < t.length - 1; l++)
    if (n[t[l]] !== void 0)
      n = n[t[l]];
    else {
      console.warn(`Property path is not valid: ${t.join(".")}`);
      return;
    }
  const a = t[t.length - 1];
  n[a] !== void 0 ? n[a] = o : console.warn(`Property path is not valid: ${t.join(".")}`);
}
function tr(e) {
  const r = new MeshBasicMaterial({
    color: 11003607,
    // Highlight color, e.g., yellow
    transparent: true,
    opacity: 0.2,
    depthTest: false,
    // So the highlight is always visible
    side: DoubleSide
    // To e
  });
  return new Gt(e.geometry.clone(), r);
}
function xe(e) {
  var t;
  let r = e.value;
  return e.value && ((t = e.value) != null && t.isMesh) && (r = e.value.position), Array.isArray(e.value) && (r = new Vector3(...r)), r;
}
var rr = Number.parseInt(REVISION.replace("dev", ""));
var z = {
  realistic: {
    shadows: true,
    physicallyCorrectLights: true,
    outputColorSpace: SRGBColorSpace,
    toneMapping: ACESFilmicToneMapping,
    toneMappingExposure: 3,
    shadowMap: {
      enabled: true,
      type: PCFSoftShadowMap
    }
  }
};
function or({
  scene: e,
  canvas: r,
  options: t,
  disableRender: o,
  contextParts: { sizes: s, camera: i }
}) {
  const n = computed(() => ({
    alpha: toValue(t.alpha),
    depth: toValue(t.depth),
    canvas: unrefElement(r),
    context: toValue(t.context),
    stencil: toValue(t.stencil),
    antialias: toValue(t.antialias) === void 0 ? true : toValue(t.antialias),
    precision: toValue(t.precision),
    powerPreference: toValue(t.powerPreference),
    premultipliedAlpha: toValue(t.premultipliedAlpha),
    preserveDrawingBuffer: toValue(t.preserveDrawingBuffer),
    logarithmicDepthBuffer: toValue(t.logarithmicDepthBuffer),
    failIfMajorPerformanceCaveat: toValue(t.failIfMajorPerformanceCaveat)
  })), a = shallowRef(new WebGLRenderer(n.value));
  watch(n, () => {
    a.value.dispose(), a.value = new WebGLRenderer(n.value);
  }), watchEffect(() => {
    a.value.setSize(s.width.value, s.height.value);
  });
  const { pixelRatio: l } = useDevicePixelRatio();
  watchEffect(() => {
    a.value.setPixelRatio(l.value);
  });
  const { logError: c } = P(), d = (() => {
    const p = new WebGLRenderer(), y = {
      shadowMap: {
        enabled: p.shadowMap.enabled,
        type: p.shadowMap.type
      },
      toneMapping: p.toneMapping,
      toneMappingExposure: p.toneMappingExposure,
      outputColorSpace: p.outputColorSpace
    };
    return p.dispose(), y;
  })();
  watchEffect(() => {
    const p = toValue(t.preset);
    p && (p in z || c(`Renderer Preset must be one of these: ${Object.keys(z).join(", ")}`), Ee(a.value, z[p]));
    const y = (C, x) => {
      const w = toValue(C), S = () => {
        if (p)
          return de(z[p], x);
      };
      if (w !== void 0)
        return w;
      const v = S();
      return v !== void 0 ? v : de(d, x);
    }, b = (C, x) => Kt(a.value, x, y(C, x));
    b(t.shadows, "shadowMap.enabled"), b(t.toneMapping, "toneMapping"), b(t.shadowMapType, "shadowMap.type"), rr < 150 && b(!t.useLegacyLights, "physicallyCorrectLights"), b(t.outputColorSpace, "outputColorSpace"), b(t.toneMappingExposure, "toneMappingExposure");
    const M = y(t.clearColor, "clearColor");
    M && a.value.setClearColor(
      M ? Ut(M) : new Color(0)
      // default clear color is not easily/efficiently retrievable from three
    );
  });
  const { pause: u, resume: f, onLoop: h2 } = G();
  return h2(() => {
    i.value && !toValue(o) && a.value.render(e, i.value);
  }), f(), onUnmounted(() => {
    u(), a.value.dispose(), a.value.forceContextLoss();
  }), {
    renderer: a
  };
}
var fe = (e) => typeof e == "function";
var nr = (e) => !!e && e.constructor === Array;
function sr(e) {
  const r = { nodes: {}, materials: {} };
  return e && e.traverse((t) => {
    t.name && (r.nodes[t.name] = t), t.material && !r.materials[t.material.name] && (r.materials[t.material.name] = t.material);
  }), r;
}
async function zr(e, r, t, o, s) {
  const { logError: i } = P(), n = new e();
  s && s(n), t && t(n);
  const l = (Array.isArray(r) ? r : [r]).map(
    (c) => new Promise((m, d) => {
      n.load(
        c,
        (u) => {
          u.scene && Object.assign(u, sr(u.scene)), m(u);
        },
        o,
        (u) => d(i("[useLoader] - Failed to load resource", u))
      );
    })
  );
  return nr(r) ? await Promise.all(l) : await l[0];
}
async function Nr(e, r) {
  const t = new TextureLoader(r), o = (s) => new Promise((i, n) => {
    t.load(
      s,
      (a) => i(a),
      () => null,
      () => {
        n(new Error("[useTextures] - Failed to load texture"));
      }
    );
  });
  if (Zt(e)) {
    const s = await Promise.all(e.map((i) => o(i)));
    return e.length > 1 ? s : s[0];
  } else {
    const {
      map: s,
      displacementMap: i,
      normalMap: n,
      roughnessMap: a,
      metalnessMap: l,
      aoMap: c,
      alphaMap: m,
      matcap: d
    } = e;
    return {
      map: s ? await o(s) : null,
      displacementMap: i ? await o(i) : null,
      normalMap: n ? await o(n) : null,
      roughnessMap: a ? await o(a) : null,
      metalnessMap: l ? await o(l) : null,
      aoMap: c ? await o(c) : null,
      alphaMap: m ? await o(m) : null,
      matcap: d ? await o(d) : null
    };
  }
}
var ir = (e, { renderer: r, camera: t, raycaster: o }) => {
  const s = computed(() => r.value.domElement), { x: i, y: n } = usePointer({ target: s }), { width: a, height: l, top: c, left: m } = useElementBounding(s), d = ({ x: v, y: _ }) => {
    if (s.value)
      return {
        x: (v - m.value) / a.value * 2 - 1,
        y: -((_ - c.value) / l.value) * 2 + 1
      };
  }, u = ({ x: v, y: _ }) => {
    if (t.value)
      return o.value.setFromCamera(new Vector2(v, _), t.value), o.value.intersectObjects(e.value, false);
  }, f = (v) => {
    const _ = d({
      x: (v == null ? void 0 : v.clientX) ?? i.value,
      y: (v == null ? void 0 : v.clientY) ?? n.value
    });
    return _ ? u(_) || [] : [];
  }, h2 = computed(() => f()), p = createEventHook(), y = createEventHook(), b = (v, _) => {
    v.trigger({ event: _, intersects: f(_) });
  }, M = (v) => {
    b(y, v);
  };
  let C;
  const x = (v) => {
    var _;
    C = (_ = f(v)[0]) == null ? void 0 : _.object;
  }, w = (v) => {
    var _;
    v instanceof PointerEvent && C === ((_ = f(v)[0]) == null ? void 0 : _.object) && b(p, v);
  }, S = (v) => y.trigger({ event: v, intersects: [] });
  return s.value.addEventListener("pointerup", w), s.value.addEventListener("pointerdown", x), s.value.addEventListener("pointermove", M), s.value.addEventListener("pointerleave", S), onUnmounted(() => {
    s != null && s.value && (s.value.removeEventListener("pointerup", w), s.value.removeEventListener("pointerdown", x), s.value.removeEventListener("pointermove", M), s.value.removeEventListener("pointerleave", S));
  }), {
    intersects: h2,
    onClick: (v) => p.on(v).off,
    onPointerMove: (v) => y.on(v).off
  };
};
function Wr() {
  const { logWarning: e } = P();
  function r(i, n, a) {
    let l = null;
    return i.traverse((c) => {
      c[n] === a && (l = c);
    }), l || e(`Child with ${n} '${a}' not found.`), l;
  }
  function t(i, n, a) {
    const l = [];
    return i.traverse((c) => {
      c[n].includes(a) && l.push(c);
    }), l.length || e(`Children with ${n} '${a}' not found.`), l;
  }
  function o(i, n) {
    return r(i, "name", n);
  }
  function s(i, n) {
    return t(i, "name", n);
  }
  return {
    seek: r,
    seekByName: o,
    seekAll: t,
    seekAllByName: s
  };
}
var ar = ({ scene: e, contextParts: r }) => {
  const t = reactive({
    click: /* @__PURE__ */ new Map(),
    pointerMove: /* @__PURE__ */ new Map(),
    pointerEnter: /* @__PURE__ */ new Map(),
    pointerLeave: /* @__PURE__ */ new Map()
  }), o = ref(/* @__PURE__ */ new Set()), s = (u) => {
    o.value.add(u);
  }, i = (u) => {
    o.value.delete(u);
  }, n = (u) => {
    Object.values(t).forEach((f) => f.delete(u)), i(u);
  }, a = (u) => {
    const { onClick: f, onPointerMove: h2, onPointerEnter: p, onPointerLeave: y } = u;
    f && t.click.set(u, f), h2 && t.pointerMove.set(u, h2), p && t.pointerEnter.set(u, p), y && t.pointerLeave.set(u, y);
  };
  e.userData.tres__registerAtPointerEventHandler = a, e.userData.tres__deregisterAtPointerEventHandler = n, e.userData.tres__registerBlockingObjectAtPointerEventHandler = s, e.userData.tres__deregisterBlockingObjectAtPointerEventHandler = i;
  const l = computed(
    () => Yt(
      [
        ...Array.from(o.value),
        ...Object.values(t).map((u) => Array.from(u.keys())).flat()
      ],
      ({ uuid: u }) => u
    )
  ), { onClick: c, onPointerMove: m } = ir(l, r);
  c(({ intersects: u, event: f }) => {
    var h2;
    u.length && ((h2 = t.click.get(u[0].object)) == null || h2(u[0], f));
  });
  let d;
  return m(({ intersects: u, event: f }) => {
    var M, C, x, w;
    const h2 = (M = u == null ? void 0 : u[0]) == null ? void 0 : M.object, { pointerLeave: p, pointerEnter: y, pointerMove: b } = t;
    d && d !== h2 && ((C = p.get(d)) == null || C(d, f)), h2 && (d !== h2 && ((x = y.get(h2)) == null || x(u[0], f)), (w = b.get(h2)) == null || w(u[0], f)), d = h2 || null;
  }), {
    registerObject: a,
    deregisterObject: n
  };
};
function Me(e) {
  let r = 0;
  return e.traverse((t) => {
    if (t.isMesh && t.geometry) {
      const o = t.geometry, s = o.attributes.position.count * 3 * Float32Array.BYTES_PER_ELEMENT, i = o.index ? o.index.count * Uint32Array.BYTES_PER_ELEMENT : 0, n = o.attributes.normal ? o.attributes.normal.count * 3 * Float32Array.BYTES_PER_ELEMENT : 0, a = o.attributes.uv ? o.attributes.uv.count * 2 * Float32Array.BYTES_PER_ELEMENT : 0, l = s + i + n + a;
      r += l;
    }
  }), r;
}
function lr(e) {
  return (e / 1024).toFixed(2);
}
var Z = ref({});
var oe = (e) => Object.assign(Z.value, e);
function ur(e, r, t = 10) {
  const o = toValue(e) ? useWindowSize() : useElementSize(computed(() => toValue(r).parentElement)), s = readonly(refDebounced(o.width, t)), i = readonly(refDebounced(o.height, t)), n = computed(() => s.value / i.value);
  return {
    height: i,
    width: s,
    aspectRatio: n
  };
}
function cr({
  scene: e,
  canvas: r,
  windowSize: t,
  disableRender: o,
  rendererOptions: s
}) {
  const i = ur(t, r), n = shallowRef(e), {
    camera: a,
    cameras: l,
    registerCamera: c,
    deregisterCamera: m,
    setCameraActive: d
  } = Nt({ sizes: i, scene: e }), { renderer: u } = or(
    {
      scene: e,
      canvas: r,
      options: s,
      contextParts: { sizes: i, camera: a },
      disableRender: o
    }
  ), f = {
    sizes: i,
    scene: n,
    camera: a,
    cameras: readonly(l),
    renderer: u,
    raycaster: shallowRef(new Raycaster()),
    controls: ref(null),
    perf: {
      maxFrames: 160,
      fps: {
        value: 0,
        accumulator: []
      },
      memory: {
        currentMem: 0,
        allocatedMem: 0,
        accumulator: []
      }
    },
    extend: oe,
    registerCamera: c,
    setCameraActive: d,
    deregisterCamera: m
  };
  provide("useTres", f);
  const h2 = 100, p = useFps({ every: h2 }), { isSupported: y, memory: b } = useMemory({ interval: h2 }), M = 160;
  let C = performance.now();
  const x = ({ timestamp: _ }) => {
    f.scene.value && (f.perf.memory.allocatedMem = Me(f.scene.value)), _ - C >= h2 && (C = _, f.perf.fps.accumulator.push(p.value), f.perf.fps.accumulator.length > M && f.perf.fps.accumulator.shift(), f.perf.fps.value = p.value, y.value && b.value && (f.perf.memory.accumulator.push(b.value.usedJSHeapSize / 1024 / 1024), f.perf.memory.accumulator.length > M && f.perf.memory.accumulator.shift(), f.perf.memory.currentMem = f.perf.memory.accumulator.reduce((Ae, Le) => Ae + Le, 0) / f.perf.memory.accumulator.length));
  };
  let w = 0;
  const S = 1, { pause: v } = useRafFn(({ delta: _ }) => {
    window.__TRES__DEVTOOLS__ && (x({ timestamp: performance.now() }), w += _, w >= S && (window.__TRES__DEVTOOLS__.cb(f), w = 0));
  }, { immediate: true });
  return onUnmounted(() => {
    v();
  }), f;
}
function dr() {
  const e = inject("useTres");
  if (!e)
    throw new Error("useTresContext must be used together with useTresContextProvider");
  return e;
}
var Vr = dr;
var g = null;
var { logError: pe } = P();
var J = [
  "onClick",
  "onPointerMove",
  "onPointerEnter",
  "onPointerLeave"
];
var fr = {
  createElement(e, r, t, o) {
    var n, a;
    if (o || (o = {}), o.args || (o.args = []), e === "template" || qt(e))
      return null;
    let s = e.replace("Tres", ""), i;
    if (e === "primitive") {
      (o == null ? void 0 : o.object) === void 0 && pe("Tres primitives need a prop 'object'");
      const l = o.object;
      s = l.type, i = Object.assign(l, { type: s, attach: o.attach, primitive: true });
    } else {
      const l = Z.value[s];
      l || pe(`${s} is not defined on the THREE namespace. Use extend to add it to the catalog.`), i = new l(...o.args);
    }
    return i.isCamera && (o != null && o.position || i.position.set(3, 3, 3), o != null && o.lookAt || i.lookAt(0, 0, 0)), (o == null ? void 0 : o.attach) === void 0 && (i.isMaterial ? i.attach = "material" : i.isBufferGeometry && (i.attach = "geometry")), i.isObject3D && ((n = o == null ? void 0 : o.material) != null && n.isMaterial && (i.userData.tres__materialViaProp = true), (a = o == null ? void 0 : o.geometry) != null && a.isBufferGeometry && (i.userData.tres__geometryViaProp = true)), i.userData = {
      ...i.userData,
      tres__name: s
    }, i;
  },
  insert(e, r) {
    var o, s, i, n;
    r && r.isScene && (g = r);
    const t = r || g;
    if (e != null && e.isObject3D) {
      if (e != null && e.isCamera) {
        if (!(g != null && g.userData.tres__registerCamera))
          throw new Error("could not find tres__registerCamera on scene's userData");
        (s = g == null ? void 0 : (o = g.userData).tres__registerCamera) == null || s.call(o, e);
      }
      if (e && J.some((a) => e[a])) {
        if (!(g != null && g.userData.tres__registerAtPointerEventHandler))
          throw new Error("could not find tres__registerAtPointerEventHandler on scene's userData");
        (n = g == null ? void 0 : (i = g.userData).tres__registerAtPointerEventHandler) == null || n.call(i, e);
      }
    }
    e != null && e.isObject3D && (t != null && t.isObject3D) ? (t.add(e), e.dispatchEvent({ type: "added" })) : e != null && e.isFog ? t.fog = e : typeof (e == null ? void 0 : e.attach) == "string" && (e.__previousAttach = e[t == null ? void 0 : t.attach], t && (t[e.attach] = e));
  },
  remove(e) {
    var r, t;
    if (e) {
      if (e.isObject3D) {
        const o = e, s = (c) => {
          var d, u;
          const m = c;
          c.userData.tres__materialViaProp || ((d = m.material) == null || d.dispose(), m.material = void 0), c.userData.tres__geometryViaProp || ((u = m.geometry) == null || u.dispose(), m.geometry = void 0);
        }, i = g == null ? void 0 : g.userData.tres__deregisterAtPointerEventHandler, n = g == null ? void 0 : g.userData.tres__deregisterBlockingObjectAtPointerEventHandler, a = (c) => {
          var m, d;
          if (!n)
            throw new Error("could not find tres__deregisterBlockingObjectAtPointerEventHandler on scene's userData");
          if ((d = g == null ? void 0 : (m = g.userData).tres__deregisterBlockingObjectAtPointerEventHandler) == null || d.call(m, c), !i)
            throw new Error("could not find tres__deregisterAtPointerEventHandler on scene's userData");
          c && J.some((u) => c[u]) && (i == null || i(c));
        }, l = (c) => {
          const m = g == null ? void 0 : g.userData.tres__deregisterCamera;
          if (!m)
            throw new Error("could not find tres__deregisterCamera on scene's userData");
          c.isCamera && (m == null || m(c));
        };
        (r = e.removeFromParent) == null || r.call(e), o.traverse((c) => {
          s(c), l(c), a == null || a(c);
        }), s(o), l(o), a == null || a(o);
      }
      (t = e.dispose) == null || t.call(e);
    }
  },
  patchProp(e, r, t, o) {
    var s, i, n, a;
    if (e) {
      let l = e, c = r;
      if (e.isObject3D && c === "blocks-pointer-events") {
        o || o === "" ? (i = g == null ? void 0 : (s = g.userData).tres__registerBlockingObjectAtPointerEventHandler) == null || i.call(s, e) : (a = g == null ? void 0 : (n = g.userData).tres__deregisterBlockingObjectAtPointerEventHandler) == null || a.call(n, e);
        return;
      }
      let m = $(c), d = l == null ? void 0 : l[m];
      if (c === "args") {
        const f = e, h2 = t ?? [], p = o ?? [], y = e.userData.tres__name || e.type;
        y && h2.length && !Xt(h2, p) && (l = Object.assign(f, new Z.value[y](...o)));
        return;
      }
      if (l.type === "BufferGeometry") {
        if (c === "args")
          return;
        l.setAttribute(
          $(c),
          new BufferAttribute(...o)
        );
        return;
      }
      if (c.includes("-") && d === void 0) {
        const f = c.split("-");
        d = f.reduce((h2, p) => h2[$(p)], l), c = f.pop(), m = c.toLowerCase(), d != null && d.set || (l = f.reduce((h2, p) => h2[$(p)], l));
      }
      let u = o;
      if (u === "" && (u = true), fe(d)) {
        J.includes(r) || (Array.isArray(u) ? e[m](...u) : e[m](u));
        return;
      }
      !(d != null && d.set) && !fe(d) ? l[m] = u : d.constructor === u.constructor && (d != null && d.copy) ? d == null || d.copy(u) : Array.isArray(u) ? d.set(...u) : !d.isColor && d.setScalar ? d.setScalar(u) : d.set(u);
    }
  },
  parentNode(e) {
    return (e == null ? void 0 : e.parent) || null;
  },
  createText: () => void 0,
  createComment: () => void 0,
  setText: () => void 0,
  setElementText: () => void 0,
  nextSibling: () => void 0,
  querySelector: () => void 0,
  setScopeId: () => void 0,
  cloneNode: () => void 0,
  insertStaticContent: () => void 0
};
var { render: pr } = createRenderer(fr);
oe(three_module_exports);
function mr() {
  return Se().__VUE_DEVTOOLS_GLOBAL_HOOK__;
}
function Se() {
  return typeof navigator < "u" && typeof window < "u" ? window : typeof globalThis < "u" ? globalThis : {};
}
var gr = typeof Proxy == "function";
var vr = "devtools-plugin:setup";
var hr = "plugin:settings:set";
var O;
var ee;
function yr() {
  var e;
  return O !== void 0 || (typeof window < "u" && window.performance ? (O = true, ee = window.performance) : typeof globalThis < "u" && (!((e = globalThis.perf_hooks) === null || e === void 0) && e.performance) ? (O = true, ee = globalThis.perf_hooks.performance) : O = false), O;
}
function wr() {
  return yr() ? ee.now() : Date.now();
}
var _r = class {
  constructor(r, t) {
    this.target = null, this.targetQueue = [], this.onQueue = [], this.plugin = r, this.hook = t;
    const o = {};
    if (r.settings)
      for (const n in r.settings) {
        const a = r.settings[n];
        o[n] = a.defaultValue;
      }
    const s = `__vue-devtools-plugin-settings__${r.id}`;
    let i = Object.assign({}, o);
    try {
      const n = localStorage.getItem(s), a = JSON.parse(n);
      Object.assign(i, a);
    } catch {
    }
    this.fallbacks = {
      getSettings() {
        return i;
      },
      setSettings(n) {
        try {
          localStorage.setItem(s, JSON.stringify(n));
        } catch {
        }
        i = n;
      },
      now() {
        return wr();
      }
    }, t && t.on(hr, (n, a) => {
      n === this.plugin.id && this.fallbacks.setSettings(a);
    }), this.proxiedOn = new Proxy({}, {
      get: (n, a) => this.target ? this.target.on[a] : (...l) => {
        this.onQueue.push({
          method: a,
          args: l
        });
      }
    }), this.proxiedTarget = new Proxy({}, {
      get: (n, a) => this.target ? this.target[a] : a === "on" ? this.proxiedOn : Object.keys(this.fallbacks).includes(a) ? (...l) => (this.targetQueue.push({
        method: a,
        args: l,
        resolve: () => {
        }
      }), this.fallbacks[a](...l)) : (...l) => new Promise((c) => {
        this.targetQueue.push({
          method: a,
          args: l,
          resolve: c
        });
      })
    });
  }
  async setRealTarget(r) {
    this.target = r;
    for (const t of this.onQueue)
      this.target.on[t.method](...t.args);
    for (const t of this.targetQueue)
      t.resolve(await this.target[t.method](...t.args));
  }
};
function br(e, r) {
  const t = e, o = Se(), s = mr(), i = gr && t.enableEarlyProxy;
  if (s && (o.__VUE_DEVTOOLS_PLUGIN_API_AVAILABLE__ || !i))
    s.emit(vr, e, r);
  else {
    const n = i ? new _r(t, s) : null;
    (o.__VUE_DEVTOOLS_PLUGINS__ = o.__VUE_DEVTOOLS_PLUGINS__ || []).push({
      pluginDescriptor: t,
      setupFn: r,
      proxy: n
    }), n && r(n.proxiedTarget);
  }
}
function Er(e, r) {
  const t = `▲ ■ ●${e}`;
  typeof __VUE_DEVTOOLS_TOAST__ == "function" ? __VUE_DEVTOOLS_TOAST__(t, r) : r === "error" ? console.error(t) : r === "warn" ? console.warn(t) : console.log(t);
}
var ke = (e) => {
  const r = {
    id: e.uuid,
    label: e.type,
    children: [],
    tags: []
  };
  e.name !== "" && r.tags.push({
    label: e.name,
    textColor: 5750629,
    backgroundColor: 15793395
  });
  const t = Me(e);
  return t > 0 && r.tags.push({
    label: `${lr(t)} KB`,
    textColor: 15707189,
    backgroundColor: 16775644,
    tooltip: "Memory usage"
  }), e.type.includes("Light") && (r.tags.push({
    label: `${e.intensity}`,
    textColor: 9738662,
    backgroundColor: 16316922,
    tooltip: "Intensity"
  }), r.tags.push({
    label: `#${e.color.getHexString()}`,
    textColor: 9738662,
    backgroundColor: 16316922,
    tooltip: "Color"
  })), e.type.includes("Camera") && (r.tags.push({
    label: `${e.fov}°`,
    textColor: 9738662,
    backgroundColor: 16316922,
    tooltip: "Field of view"
  }), r.tags.push({
    label: `x: ${Math.round(e.position.x)} y: ${Math.round(e.position.y)} z: ${Math.round(e.position.z)}`,
    textColor: 9738662,
    backgroundColor: 16316922,
    tooltip: "Position"
  })), r;
};
function Pe(e, r) {
  e.children.forEach((t) => {
    if (t.type === "HightlightMesh")
      return;
    const o = ke(t);
    r.children.push(o), Pe(t, o);
  });
}
var Cr = [];
var D = "tres:inspector";
var xr = reactive({
  sceneGraph: null
});
function Mr(e, r) {
  br(
    {
      id: "dev.esm.tres",
      label: "TresJS 🪐",
      logo: "https://raw.githubusercontent.com/Tresjs/tres/main/public/favicon.svg",
      packageName: "tresjs",
      homepage: "https://tresjs.org",
      componentStateTypes: Cr,
      app: e
    },
    (t) => {
      typeof t.now != "function" && Er(
        "You seem to be using an outdated version of Vue Devtools. Are you still using the Beta release instead of the stable one? You can find the links at https://devtools.vuejs.org/guide/installation.html."
      ), t.addInspector({
        id: D,
        label: "TresJS 🪐",
        icon: "account_tree",
        treeFilterPlaceholder: "Search instances"
      }), setInterval(() => {
        t.sendInspectorTree(D);
      }, 1e3), setInterval(() => {
        t.notifyComponentUpdate();
      }, 5e3), t.on.getInspectorTree((i) => {
        if (i.inspectorId === D) {
          const n = ke(r.scene.value);
          Pe(r.scene.value, n), xr.sceneGraph = n, i.rootNodes = [n];
        }
      });
      let o = null, s = null;
      t.on.getInspectorState((i) => {
        if (i.inspectorId === D) {
          const [n] = r.scene.value.getObjectsByProperty("uuid", i.nodeId);
          if (!n)
            return;
          if (s && o && o.parent && s.remove(o), n.isMesh) {
            const a = tr(n);
            n.add(a), o = a, s = n;
          }
          i.state = {
            object: [
              {
                key: "uuid",
                editable: true,
                value: n.uuid
              },
              {
                key: "name",
                editable: true,
                value: n.name
              },
              {
                key: "type",
                editable: true,
                value: n.type
              },
              {
                key: "position",
                editable: true,
                value: n.position
              },
              {
                key: "rotation",
                editable: true,
                value: n.rotation
              },
              {
                key: "scale",
                editable: true,
                value: n.scale
              },
              {
                key: "geometry",
                value: n.geometry
              },
              {
                key: "material",
                value: n.material
              },
              {
                key: "color",
                editable: true,
                value: n.color
              },
              {
                key: "intensity",
                editable: true,
                value: n.intensity
              },
              {
                key: "castShadow",
                editable: true,
                value: n.castShadow
              },
              {
                key: "receiveShadow",
                editable: true,
                value: n.receiveShadow
              },
              {
                key: "frustumCulled",
                editable: true,
                value: n.frustumCulled
              },
              {
                key: "matrixAutoUpdate",
                editable: true,
                value: n.matrixAutoUpdate
              },
              {
                key: "matrixWorldNeedsUpdate",
                editable: true,
                value: n.matrixWorldNeedsUpdate
              },
              {
                key: "matrixWorld",
                value: n.matrixWorld
              },
              {
                key: "visible",
                editable: true,
                value: n.visible
              }
            ]
          };
        }
      }), t.on.editInspectorState((i) => {
        i.inspectorId === D && er(r.scene.value, i.nodeId, i.path, i.state.value);
      });
    }
  );
}
var Sr = ["data-scene", "data-tres"];
var kr = defineComponent({
  __name: "TresCanvas",
  props: {
    shadows: { type: Boolean, default: void 0 },
    clearColor: {},
    toneMapping: {},
    shadowMapType: {},
    useLegacyLights: { type: Boolean, default: void 0 },
    outputColorSpace: {},
    toneMappingExposure: {},
    camera: {},
    preset: {},
    windowSize: { type: Boolean, default: void 0 },
    disableRender: { type: Boolean, default: void 0 },
    context: {},
    precision: {},
    alpha: { type: Boolean, default: void 0 },
    premultipliedAlpha: { type: Boolean },
    antialias: { type: Boolean, default: void 0 },
    stencil: { type: Boolean, default: void 0 },
    preserveDrawingBuffer: { type: Boolean, default: void 0 },
    powerPreference: {},
    depth: { type: Boolean, default: void 0 },
    logarithmicDepthBuffer: { type: Boolean, default: void 0 },
    failIfMajorPerformanceCaveat: { type: Boolean, default: void 0 }
  },
  setup(e, { expose: r }) {
    var h2;
    const t = e, o = useSlots(), { logWarning: s } = P(), i = ref(), n = shallowRef(new Scene()), { resume: a } = G(), l = (h2 = getCurrentInstance()) == null ? void 0 : h2.appContext.app, c = (p) => defineComponent({
      setup() {
        var b;
        const y = (b = getCurrentInstance()) == null ? void 0 : b.appContext;
        return y && (y.app = l), provide("useTres", p), provide("extend", oe), typeof window < "u" && Mr(y.app, p), () => h(Fragment, null, o != null && o.default ? o.default() : []);
      }
    }), m = (p) => {
      const y = c(p);
      pr(h(y), n.value);
    }, d = (p, y = false) => {
      n.value.children = [], y && (p.renderer.value.dispose(), p.renderer.value.renderLists.dispose(), p.renderer.value.forceContextLoss()), m(p), a();
    }, u = computed(() => t.disableRender), f = shallowRef(null);
    return r({ context: f, dispose: () => d(f.value, true) }), onMounted(() => {
      const p = i;
      f.value = cr({
        scene: n.value,
        canvas: p,
        windowSize: t.windowSize,
        disableRender: u,
        rendererOptions: t
      }), ar({ scene: n.value, contextParts: f.value });
      const { registerCamera: y, camera: b, cameras: M, deregisterCamera: C } = f.value;
      m(f.value);
      const x = () => {
        const w = new PerspectiveCamera(
          45,
          window.innerWidth / window.innerHeight,
          0.1,
          1e3
        );
        w.position.set(3, 3, 3), w.lookAt(0, 0, 0), y(w);
        const S = watchEffect(() => {
          M.value.length >= 2 && (w.removeFromParent(), C(w), S == null || S());
        });
      };
      watch(
        () => t.camera,
        (w, S) => {
          w && y(w), S && (S.removeFromParent(), C(S));
        },
        {
          immediate: true
        }
      ), b.value || (s(
        "No camera found. Creating a default perspective camera. To have full control over a camera, please add one to the scene."
      ), x());
    }), (p, y) => (openBlock(), createElementBlock("canvas", {
      ref_key: "canvas",
      ref: i,
      "data-scene": n.value.uuid,
      class: normalizeClass(p.$attrs.class),
      "data-tres": `tresjs ${unref(zt).version}`,
      style: normalizeStyle({
        display: "block",
        width: "100%",
        height: "100%",
        position: p.windowSize ? "fixed" : "relative",
        top: 0,
        left: 0,
        pointerEvents: "auto",
        touchAction: "none",
        ...p.$attrs.style
      })
    }, null, 14, Sr));
  }
});
var Pr = [
  "TresCanvas",
  "TresLeches",
  "TresScene"
];
var Tr = {
  template: {
    compilerOptions: {
      isCustomElement: (e) => e.startsWith("Tres") && !Pr.includes(e) || e === "primitive"
    }
  }
};
var Fr = Tr;
var Ur = {
  mounted: (e, r) => {
    if (r.arg) {
      console.log(`v-log:${r.arg}`, e[r.arg]);
      return;
    }
    console.log("v-log", e);
  }
};
var Te = class extends Line {
  constructor(r, t) {
    const o = [1, 1, 0, -1, 1, 0, -1, -1, 0, 1, -1, 0, 1, 1, 0], s = new BufferGeometry();
    s.setAttribute("position", new Float32BufferAttribute(o, 3)), s.computeBoundingSphere();
    const i = new LineBasicMaterial({ fog: false });
    super(s, i), this.light = r, this.color = t, this.type = "RectAreaLightHelper";
    const n = [1, 1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, -1, 0, 1, -1, 0], a = new BufferGeometry();
    a.setAttribute("position", new Float32BufferAttribute(n, 3)), a.computeBoundingSphere(), this.add(new Mesh(a, new MeshBasicMaterial({ side: BackSide, fog: false })));
  }
  updateMatrixWorld() {
    if (this.scale.set(0.5 * this.light.width, 0.5 * this.light.height, 1), this.color !== void 0)
      this.material.color.set(this.color), this.children[0].material.color.set(this.color);
    else {
      this.material.color.copy(this.light.color).multiplyScalar(this.light.intensity);
      const r = this.material.color, t = Math.max(r.r, r.g, r.b);
      t > 1 && r.multiplyScalar(1 / t), this.children[0].material.color.copy(this.material.color);
    }
    this.matrixWorld.extractRotation(this.light.matrixWorld).scale(this.scale).copyPosition(this.light.matrixWorld), this.children[0].matrixWorld.copy(this.matrixWorld);
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose(), this.children[0].geometry.dispose(), this.children[0].material.dispose();
  }
};
var { logWarning: me } = P();
var N;
var T;
var Ar = {
  DirectionalLight: DirectionalLightHelper,
  PointLight: PointLightHelper,
  SpotLight: SpotLightHelper,
  HemisphereLight: HemisphereLightHelper,
  RectAreaLight: Te
};
var Gr = {
  mounted: (e) => {
    if (!e.isLight) {
      me(`${e.type} is not a light`);
      return;
    }
    N = Ar[e.type], e.parent.add(new N(e, 1, e.color.getHex()));
  },
  updated: (e) => {
    T = e.parent.children.find((r) => r instanceof N), !(T instanceof Te) && T.update();
  },
  unmounted: (e) => {
    if (!e.isLight) {
      me(`${e.type} is not a light`);
      return;
    }
    T = e.parent.children.find((r) => r instanceof N), T && T.dispose && T.dispose(), e.parent.remove(T);
  }
};
var { logWarning: Lr } = P();
var Qr = {
  updated: (e, r) => {
    const t = xe(r);
    if (!t) {
      Lr(`v-always-look-at: problem with binding value: ${r.value}`);
      return;
    }
    const { onLoop: o } = G();
    o(() => {
      e.lookAt(t);
    });
  }
};
var { logWarning: Or } = P();
var k = null;
var qr = {
  updated: (e, r) => {
    var s;
    const t = xe(r);
    if (!t) {
      Or(`v-distance-to: problem with binding value: ${r.value}`);
      return;
    }
    k && (k.dispose(), e.parent.remove(k));
    const o = t.clone().sub(e.position);
    o.normalize(), k = new ArrowHelper(o, e.position, e.position.distanceTo(t), 16776960), e.parent.add(k), console.table(
      [
        ["Distance:", e.position.distanceTo(t)],
        [`origin: ${e.name || e.type}`, `x:${e.position.x}, y:${e.position.y}, z:${(s = e.position) == null ? void 0 : s.z}`],
        [`Destiny: ${e.name || e.type}`, `x:${t.x}, y:${t.y}, z:${t == null ? void 0 : t.z}`]
      ]
    );
  },
  unmounted: (e) => {
    k == null || k.dispose(), e.parent.remove(k);
  }
};
var { logWarning: Dr } = P();
var Jr = {
  mounted: (e, r) => {
    if (e.isCamera) {
      Dr(`Rotate the ${e.type} is not a good idea`);
      return;
    }
    const t = r.value ?? 0.01, o = ref(r.modifiers.x || r.arg === "x" ? 1 : 0), s = ref(r.modifiers.y || r.arg === "y" ? 1 : 0), i = ref(r.modifiers.z || r.arg === "z" ? 1 : 0);
    o.value + s.value + i.value === 0 && (o.value = 1, s.value = 1);
    const n = new Quaternion().setFromAxisAngle(new Vector3(o.value, s.value, i.value).normalize(), t), { onLoop: a } = G();
    a(() => {
      e.applyQuaternion(n);
    });
  }
};
var Yr = {
  install(e) {
    e.component("TresCanvas", kr);
  }
};

export {
  Nt,
  G,
  Ir,
  P,
  $r,
  Ut,
  or,
  sr,
  zr,
  Nr,
  ir,
  Wr,
  ar,
  Z,
  oe,
  cr,
  dr,
  Vr,
  kr,
  Fr,
  Ur,
  Gr,
  Qr,
  qr,
  Jr,
  Yr
};
//# sourceMappingURL=chunk-4OXFMVKJ.js.map
